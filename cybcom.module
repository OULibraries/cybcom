<?php

/**
 *  Implements hook_admin
 */
function cybcom_admin() {
  $form = array();

  $form['cybcom_xmlurl'] = array(
    '#type' => 'textfield',
    '#title' => t('CyberCommons URL'),
    '#default_value' => variable_get('cybcom_xmlurl', ""),
    '#required' => TRUE,
  );

  $form['cybcom_token'] = array(
    '#type' => 'textfield',
    '#title' => t('CyberCommons token'),
    '#default_value' => variable_get('cybcom_token', ""),
    '#required' => TRUE,
  );

  return system_settings_form($form);
}

/**
 *  Implements hook_menu()
 */
function cybcom_menu() {

  $items = array();

  $items['admin/config/cybcom'] = array(
    'title' => 'CyberCommons Settings',
    'description' => 'Lorem ipsum dolor sit amet',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cybcom_admin'),
    'access arguments' => array('administer cybcom settings'),
    'type' => MENU_NORMAL_ITEM,
  );

  $items['node/%cybcom_menu/cybcom/preview'] = array (
    'title' =>"JSON Preview" ,
    'type' => MENU_LOCAL_TASK,
    'page callback' => '_cybcom_loadNodeHtml',
    'page arguments' => array(1),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),

  );

 $items['node/%cybcom_menu/cybcom/json'] = array (
   'title' =>"JSON" ,
   'type' => MENU_NORMAL_ITEM,
   'page callback' => '_cybcom_loadNode',
   'page arguments' => array(1),
   'access callback' => 'node_access',
   'access arguments' => array('update', 1),
   'delivery callback' => 'drupal_json_output',
 );

 return $items;
}


/**
 * Menu loader callback.
 */
function cybcom_menu_load($nid) {
  if (!is_numeric($nid)) {
    return FALSE;
  }
  $node = node_load($nid);
  if($node->type == 'item') {
    return $node;
  }
  return FALSE;
}

/**
 *  Post to cybercommns to get XML representation of node
 */
function cybcom_mintxml($nid) {
  watchdog('cybcom', "mintxml called for node ". $nid );

  try {
    // load data to mint
    $nd = entity_load_single('node', $nid);
    $bd = $nd->type;
    $w = entity_metadata_wrapper("node", $nd, array('bundle' => $bd));

    // get config
    $cybcom_xmlurl = variable_get('cybcom_xmlurl', "");
    $cybcom_token = variable_get('cybcom_token', "");

    // structure as array for cybercommons
    $cybcom_data = _cybcom_wrap2array($w);

    //send to cyber commonds
    $response = _send2cybcom($cybcom_xmlurl, $cybcom_token, "speccoll.tmpl", $cybcom_data);

    // save resonse url
    $task= $response->json();
    $w->field_cybcom_task->set($task['task_id'] );
    $w->field_cybcom_task_uri->set( array( 'url'=>$task['result_url']));
    $w->save();

  } catch (EntityMetadataWrapperException $e) {
    watchdog(
      'cybcom',
      'EntityMetadataWrapper exception in %function() <pre>@trace</pre>',
      array('%function' => __FUNCTION__, '@trace' => $e->getTraceAsString()),
      WATCHDOG_ERROR
    );
    var_dump($e->getTrace());

  } catch(GuzzleHttp\Exception\TransferException $e) {
    watchdog('cybcom',
      "Trouble sending data to Cyber Commons %nid",
      'Guzzle exception in %function() <pre>@trace</pre>',
      array('%function' => __FUNCTION__, '@trace' => $e->getTraceAsString()),
      WATCHDOG_ERROR
    );
  }

}


function _cybcom_loadNode($node) {

 try {
   $nid = $node->nid;
   // load data to mint
   $nd = entity_load_single('node', $nid);
   $bd = $nd->type;
   $w = entity_metadata_wrapper("node", $nd, array('bundle' => $bd));

   return _cybcom_wrap2array($w);

  } catch (EntityMetadataWrapperException $e) {
    watchdog(
      'cybcom',
      'EntityMetadataWrapper exception in %function() <pre>@trace</pre>',
      array('%function' => __FUNCTION__, '@trace' => $e->getTraceAsString()),
      WATCHDOG_ERROR
    );
  }
}

function _cybcom_loadNodeHtml($node) {

  $ccArray = _cybcom_loadNode($node);

  $ccArrayMarkup  = '<pre>';
  $ccArrayMarkup .= htmlspecialchars(json_encode($ccArray, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES));
  // We don't want escaped slashes because it looks weird when we turn things in to html
  $ccArrayMarkup .='</pre>';

  $output = array(
    'content'=> array(
      '#type' => 'markup',
      '#markup' => $ccArrayMarkup,
    )


  );
  return $output;
}

function _cybcom_wrap2array($w) {
  $myContent=array();

  foreach ($w->getPropertyInfo() as $key => $val) {
    // $key will be a field name from the item content type
    // $val will be the (structured) content of that field,

    // For Drupal nodes, "title" isn't a normal entity field
    if("title" == $key) {
      $myValue = $w->$key->value();
      if(! empty(  $myValue )) {
        $myContent["title"]=$myValue;
      }
      continue;
    }

    // If it isn't an entity field or a special case that we've already handled,
    // it's probably a Drupal enternal that we should skip
    if(! preg_match('/field_.*/', $key)) {
      continue;
    }

    // Don't worry about cybercom response fields, either
    if( preg_match('/field_cybcom_task.*/', $key)) {
      continue;
    }

    // field_name could be a field name but it could also be the parent field of
    // a field collection, so we might ignore it
    if("field_name" ==$key && ! isset( $val->field)) {
      continue;
    }

    switch( $val['type'] )  {

      // Handle single and multi-value text fields.
      case "integer":
      case "boolean":
      case "text":
      case "list<text>":
        $myValue = $w->$key->value();
        if( empty(  $myValue )) { break; }

        $myContent[$key]=$myValue;
        break;

      case "taxonomy_term":
        $myValue = $w->$key->value();
        if( empty(  $myValue )) {break; }

        $myContent[$key]=$myValue->name;
        break;

      case "list<taxonomy_term>":
        $myVec = $w->$key->value();
        if( empty($myVec)) { break; }

        $getName = function($i) { return $i->name ; };
        $myContent[$key] = array_map( $getName , $myVec);
        break;

      case "date":
        $myValue = $w->$key->value();
        if( empty($myVec)) { break; }

        $myContent[$key]=date(DATE_ATOM, $myValue);
        break;

      case "list<date>":
        $myVec = $w->$key->value();
        if( empty( $myVec)) {break;}

        $getDate = function($i) { return date(DATE_ATOM, $i); };
        $myContent[$key] = array_map($getDate, $myVec);
        break;

      case "list<node>":
      case (preg_match('/list<field_collection_.*/', $val['type']) ? $val['type'] : !$val['type'] ) :
        $myVec = iterator_to_array($w->$key);
        if( empty( $myVec)) {break;}

        $getArr = function($i) { return _cybcom_wrap2array($i);};
        $myContent[$key] = array_map( $getArr, $myVec);
        break;

      case (preg_match('/list<field_.*_link>/', $val['type']) ? $val['type'] : !$val['type'] ) :
        $myVec = iterator_to_array($w->$key);
        if( empty( $myVec)) {break;}

        $getLink = function ($i) {
          $myLink = array();
          if( $i->raw() ) {
            $myLink=$i->value();
            unset($myLink['attributes']); // Get rid of context-specific attributes
          }
          return $myLink;
        };
        $myContent[$key] = array_map( $getLink, $myVec);

        break;

     case (preg_match('/field_.*_link/', $val['type']) ? $val['type'] : !$val['type'] ) :
        $myLink = array();
        if( $w->$key->raw() ) {
          $myLink=$w->$key->value();
          unset($myLink['attributes']); // Get rid of context-specific attributes
        }
        $myContent[$key] = $myLink;
        break;


      default:
        // Log unhandled fields. Eventually this should be an error
        watchdog("cybcom",
          "Unhandled field %field of type %type in entity %eid.",
          array("%field"=>$key, "%eid" => $w->getIdentifier(), "%type"=> $val['type']  )
        );
    }
  }
return $myContent;
}



function _send2cybcom($cybcom_xmlurl, $cybcom_token, $cybcom_template, $cybcom_data) {

  $cyb_client = new GuzzleHttp\Client([
                  'defaults' => [
                    'headers' => [
                      'Content-Type'=>'application/json',
                      "Authorization"=>"Token ".$cybcom_token,
                    ]]]);

  $cyb_body = [
    "function"=>"xmlgenq.tasks.xmltemplate.metadataTemplateCreation",
    "queue"=>"celery",
    "args" => [
      $cybcom_data,
    ],
    "kwargs"=> [
      "templatename"=>$cybcom_template,
      "outname"=>$cybcom_template.".xml"
    ],
    "tags"=> ["example.xml"],
  ];

  $response = $cyb_client->post(
    $cybcom_xmlurl."/api/queue/run/xmlgenq.tasks.xmltemplate.metadataTemplateCreation/.json",
    ['body' => json_encode($cyb_body),]
  );


  return $response;
}
