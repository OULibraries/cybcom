><?php

/**
 *
 */
function cybcom_admin() {
  $form = array();

  $form['cybcom_xmlurl'] = array(
    '#type' => 'textfield',
    '#title' => t('CyberCommons URL'),
    '#default_value' => variable_get('cybcom_xmlurl', ""),
    '#required' => TRUE,
  );

  $form['cybcom_token'] = array(
    '#type' => 'textfield',
    '#title' => t('CyberCommons token'),
    '#default_value' => variable_get('cybcom_token', ""),
    '#required' => TRUE,
  );

  return system_settings_form($form);
}


/**
 *  Implements hook_menu()
 */
function cybcom_menu() {

  $items = array();

  $items['admin/config/cybcom'] = array(
    'title' => 'CyberCommons Settings',
    'description' => 'Lorem ipsum dolor sit amet',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cybcom_admin'),
    'access arguments' => array('administer cybcom settings'),
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}


/**
 *  Post to cybercommns to get XML representation of node
 */

function cybcom_mintxml($nid) {

  $cybcom_xmlurl = variable_get('cybcom_xmlurl', "");
  $cybcom_token = variable_get('cybcom_token', "");



  $my_data = _cybcom_getItemArray($nid);



  $cyb_client = new GuzzleHttp\Client([
                  'defaults' => [
                    'headers' => [
                      'Content-Type'=>'application/json',
                      "Authorization"=>"Token ".$cybcom_token,
                    ]]]);

  $cyb_body = [
    "function"=>"xmlgenq.tasks.xmltemplate.metadataTemplateCreation",
    "queue"=>"celery",
    "args" => [
      $my_data,
    ],
    "kwargs"=> [
      "templatename"=>"speccoll.tmpl",
      "outname"=>"example.xml"
    ],
    "tags"=> ["example.xml"],
  ];

  $response = $cyb_client->post(
    $cybcom_xmlurl."/api/queue/run/xmlgenq.tasks.xmltemplate.metadataTemplateCreation/.json",
    ['body' => json_encode($cyb_body),]
  );

  return  $response->json();
}


function _cybcom_getItemArray($nid) {
  $myContent=array();

  try {

    $w = entity_metadata_wrapper("node", $nid, array('bundle' => 'item'));

    foreach ($w->getPropertyInfo() as $key => $val) {

      #
      # Delete special case when template moves from field_title to title
      #
      if("title" == $key) {
        $myContent["title"]=$w->$key->value();
        continue;
      }

      #
      # Delete special case when template fixes spelling of field_alternative
      #
      if("field_alternate" == $key) {
        $myContent["field_alternative"]=$w->$key->value();
        continue;
      }

      switch( $val['type'] )  {

        # Handle single and multi-value text fields.
        case "text":
        case "list<text>":
          $myValue = $w->$key->value();
          if(! empty(  $myValue )) {
            $myContent[$key]=$w->$key->value();
          }
          break;

        default:
          # Log unhandled fields. Eventually this should be an error
          watchdog("cybcom", "Unhandled field ".$key." of type ".$val[type]);
          ;
      }
    }
  } catch (EntityMetadataWrapperException $exc) {
    watchdog(
      'cybcom',
      'EntityMetadataWrapper exception in %function() <pre>@trace</pre>',
      array('%function' => __FUNCTION__, '@trace' => $exc->getTraceAsString()),
    WATCHDOG_ERROR
    );
  }
  return $myContent;
}
