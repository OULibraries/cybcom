<?php

/**
 *
 */
function cybcom_admin() {
  $form = array();

  $form['cybcom_xmlurl'] = array(
    '#type' => 'textfield',
    '#title' => t('CyberCommons URL'),
    '#default_value' => variable_get('cybcom_xmlurl', ""),
    '#required' => TRUE,
  );

  $form['cybcom_token'] = array(
    '#type' => 'textfield',
    '#title' => t('CyberCommons token'),
    '#default_value' => variable_get('cybcom_token', ""),
    '#required' => TRUE,
  );

  return system_settings_form($form);
}


/**
 *  Implements hook_menu()
 */
function cybcom_menu() {

  $items = array();

  $items['admin/config/cybcom'] = array(
    'title' => 'CyberCommons Settings',
    'description' => 'Lorem ipsum dolor sit amet',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cybcom_admin'),
    'access arguments' => array('administer cybcom settings'),
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}


/**
 *  Post to cybercommns to get XML representation of node
 */

function cybcom_mintxml($nid) {

  try {

    $w = entity_metadata_wrapper("node", $nid, array('bundle' => 'item'));


    watchdog('cybcom', "mintxml called for node ". $id->nid );

    $cybcom_xmlurl = variable_get('cybcom_xmlurl', "");
    $cybcom_token = variable_get('cybcom_token', "");

    $my_data = _cybcom_wrap2array($w);

    $cyb_client = new GuzzleHttp\Client([
                    'defaults' => [
                      'headers' => [
                        'Content-Type'=>'application/json',
                        "Authorization"=>"Token ".$cybcom_token,
                      ]]]);

    $cyb_body = [
      "function"=>"xmlgenq.tasks.xmltemplate.metadataTemplateCreation",
      "queue"=>"celery",
      "args" => [
        $my_data,
      ],
      "kwargs"=> [
        "templatename"=>"speccoll.tmpl",
        "outname"=>"example.xml"
      ],
      "tags"=> ["example.xml"],
    ];

    $response = $cyb_client->post(
      $cybcom_xmlurl."/api/queue/run/xmlgenq.tasks.xmltemplate.metadataTemplateCreation/.json",
      ['body' => json_encode($cyb_body),]
    );

    return  $response->json();

  } catch (EntityMetadataWrapperException $exc) {
    watchdog(
      'cybcom',
      'EntityMetadataWrapper exception in %function() <pre>@trace</pre>',
      array('%function' => __FUNCTION__, '@trace' => $exc->getTraceAsString()),
      WATCHDOG_ERROR
    );
  }


}


function _cybcom_wrap2array($w) {
  $myContent=array();

  foreach ($w->getPropertyInfo() as $key => $val) {

    #
    # Delete special case when template moves from field_title to title
    #
    if("title" == $key) {
      $myValue = $w->$key->value();
      if(! empty(  $myValue )) {
        $myContent["title"]=$myValue;
      }
      continue;
    }

    #
    # Delete special case when template fixes spelling of field_alternative
    #
    if("field_alternate" == $key) {
      $myValue = $w->$key->value();
      if(! empty(  $myValue )) {
        $myContent["field_alternative"]=$myValue;
      }
      continue;
    }

    switch( $val['type'] )  {

      # Handle single and multi-value text fields.
      case "integer":
      case "boolean":
      case "text":
      case "list<text>":
        $myValue = $w->$key->value();
        if(! empty(  $myValue )) {
          $myContent[$key]=$myValue;
        }
        break;

      case "taxonomy_term":
        $myValue = $w->$key->value();
        if(! empty(  $myValue )) {
          $myContent[$key]=$myValue->name;
        }
        break;

      case "list<taxonomy_term>":
        $myVec = $w->$key->value();
        $myTerms = array();
        foreach( $myVec as $myValue) {
          array_push($myTerms, $myValue->name);
        }
        if(! empty( $myTerms) ) {
          $myContent[$key]=$myTerms;
        }
        break;


      default:
        drush_print("KEY :".$key);
        drush_print("VAL :".$val['type']);
        drush_print_r($w->$key->value());

        # Log unhandled fields. Eventually this should be an error
        watchdog("cybcom", "Unhandled field ".$key." of type ".$val[type]);
        ;
    }
  }
return $myContent;
}
