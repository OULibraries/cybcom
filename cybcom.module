<?php

/**
 *
 */
function cybcom_admin() {
  $form = array();

  $form['cybcom_xmlurl'] = array(
    '#type' => 'textfield',
    '#title' => t('CyberCommons URL'),
    '#default_value' => variable_get('cybcom_xmlurl', ""),
    '#required' => TRUE,
  );

  $form['cybcom_token'] = array(
    '#type' => 'textfield',
    '#title' => t('CyberCommons token'),
    '#default_value' => variable_get('cybcom_token', ""),
    '#required' => TRUE,
  );

  return system_settings_form($form);
}


/**
 *  Implements hook_menu()
 */
function cybcom_menu() {

  $items = array();

  $items['admin/config/cybcom'] = array(
    'title' => 'CyberCommons Settings',
    'description' => 'Lorem ipsum dolor sit amet',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cybcom_admin'),
    'access arguments' => array('administer cybcom settings'),
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}


function cybcom_menu_alter(&$items) {
  // $node = menu_get_object();
  // if ($node->type != "item") {return true; }

  $items['node/%node/cybcom'] = array (
    'title' =>"Cybercommons Data",
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'type' => MENU_LOCAL_TASK,
    'page callback' => '_cybcom_loadNodeHtml',
    'page arguments' => array(1)
  );

 $items['node/%node/cybcom/json'] = array (
    'title' =>"Cybercommons Data",
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'type' => MENU_LOCAL_TASK,
    'page callback' => '_cybcom_loadNode',
    'page arguments' => array(1),
    'delivery callback' => 'drupal_json_output',
  );

}


/**
 *  Post to cybercommns to get XML representation of node
 */
function cybcom_mintxml($nid) {
  watchdog('cybcom', "mintxml called for node ". $id->nid );

  try {
    # load data to mint
    $nd = entity_load_single('node', $nid);
    $bd = $nd->type;
    $w = entity_metadata_wrapper("node", $nd, array('bundle' => $bd));

    # get config
    $cybcom_xmlurl = variable_get('cybcom_xmlurl', "");
    $cybcom_token = variable_get('cybcom_token', "");

    # structure as array for cybercommons
    $cybcom_data = _cybcom_wrap2array($w);

    #send to cyber commonds
    $response = _send2cybcom($cybcom_xmlurl, $cybcom_token, "speccoll.tmpl", $cybcom_data);

    # save resonse url
    $task= $response->json();


    $w->field_cybcom_task->set($task['task_id'] );
    $w->field_cybcom_task_uri->set( array( 'url'=>$task['result_url']));
    $w->save();

  } catch (EntityMetadataWrapperException $exc) {
    watchdog(
      'cybcom',
      'EntityMetadataWrapper exception in %function() <pre>@trace</pre>',
      array('%function' => __FUNCTION__, '@trace' => $exc->getTraceAsString()),
      WATCHDOG_ERROR
    );
  }


}


function _cybcom_loadNode($node) {

 try {
   $nid = $node->nid;
   # load data to mint
   $nd = entity_load_single('node', $nid);
   $bd = $nd->type;
   $w = entity_metadata_wrapper("node", $nd, array('bundle' => $bd));

   return _cybcom_wrap2array($w);

  } catch (EntityMetadataWrapperException $exc) {
    watchdog(
      'cybcom',
      'EntityMetadataWrapper exception in %function() <pre>@trace</pre>',
      array('%function' => __FUNCTION__, '@trace' => $exc->getTraceAsString()),
      WATCHDOG_ERROR
    );
  }
}

function _cybcom_loadNodeHtml($node) {

  $ccArray = _cybcom_loadNode($node);
  ddl($ccArray);
  $output = array(
    'header' => array(
      '#type' => 'markup',
      '#markup' => '<p>Data to send to CyberCommons</p>',
    ),
  );
  return $output;
}





function _cybcom_wrap2array($w) {
  $myContent=array();

  foreach ($w->getPropertyInfo() as $key => $val) {

    #
    # Delete special case when template moves from field_title to title
    #
    if("title" == $key) {
      $myValue = $w->$key->value();
      if(! empty(  $myValue )) {
        $myContent["title"]=$myValue;
      }
      continue;
    }

    #
    # Delete special case when template fixes spelling of field_alternative
    #
    if("field_alternate" == $key) {
      $myValue = $w->$key->value();
      if(! empty(  $myValue )) {
        $myContent["field_alternative"]=$myValue;
      }
      continue;
    }

    switch( $val['type'] )  {

      # Handle single and multi-value text fields.
      case "integer":
      case "boolean":
      case "text":
      case "list<text>":
        $myValue = $w->$key->value();
        if(! empty(  $myValue )) {
          $myContent[$key]=$myValue;
        }
        break;

      case "taxonomy_term":
        $myValue = $w->$key->value();
        if(! empty(  $myValue )) {
          $myContent[$key]=$myValue->name;
        }
        break;

      case "list<taxonomy_term>":
        $myVec = $w->$key->value();
        $myTerms = array();
        foreach( $myVec as $myValue) {
          array_push($myTerms, $myValue->name);
        }
        if(! empty( $myTerms) ) {
          $myContent[$key]=$myTerms;
        }
        break;


      case "date":
        $myValue = $w->$key->value();
        if(! empty(  $myValue )) {
          $myContent[$key]=date(DATE_RFC2822, $myValue);
        }

      case "list<date>":
        $myVec = $w->$key->value();
        if(is_array($myVec)) {break;} // Bad style?
        $myDates = array();
        foreach( $myVec as $myTS) {
          array_push($myDates, date(DATE_RFC2822. $myTS));
        }
        if(! empty( $myTerms) ) {
          $myContent[$key]=$myDates;
        }
        break;

      default:
        # Log unhandled fields. Eventually this should be an error
        watchdog("cybcom", "Unhandled field ".$key);
        ;
    }
  }
return $myContent;
}



function _send2cybcom($cybcom_xmlurl, $cybcom_token, $cybcom_template, $cybcom_data) {

  $cyb_client = new GuzzleHttp\Client([
                  'defaults' => [
                    'headers' => [
                      'Content-Type'=>'application/json',
                      "Authorization"=>"Token ".$cybcom_token,
                    ]]]);

  $cyb_body = [
    "function"=>"xmlgenq.tasks.xmltemplate.metadataTemplateCreation",
    "queue"=>"celery",
    "args" => [
      $cybcom_data,
    ],
    "kwargs"=> [
      "templatename"=>$cybcom_template,
      "outname"=>$cybcom_template.".xml"
    ],
    "tags"=> ["example.xml"],
  ];

  $response = $cyb_client->post(
    $cybcom_xmlurl."/api/queue/run/xmlgenq.tasks.xmltemplate.metadataTemplateCreation/.json",
    ['body' => json_encode($cyb_body),]
  );


  return $response;
}
