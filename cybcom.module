<?php

/**
 *  Implements hook_admin
 */
function cybcom_admin() {
  $form = array();

  $form['cybcom_xmlurl'] = array(
    '#type' => 'textfield',
    '#title' => t('CyberCommons URL'),
    '#default_value' => variable_get('cybcom_xmlurl', ""),
    '#required' => TRUE,
  );

  $form['cybcom_token'] = array(
    '#type' => 'textfield',
    '#title' => t('CyberCommons token'),
    '#default_value' => variable_get('cybcom_token', ""),
    '#required' => TRUE,
  );

  return system_settings_form($form);
}

/**
 *  Implements hook_menu()
 */
function cybcom_menu() {

  $items = array();

  $items['admin/config/cybcom'] = array(
    'title' => 'CyberCommons Settings',
    'description' => 'Lorem ipsum dolor sit amet',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cybcom_admin'),
    'access arguments' => array('administer cybcom settings'),
    'type' => MENU_NORMAL_ITEM,
  );

  $items['node/%cybcom_menu/cybcom/preview'] = array (
    'title' =>"JSON Preview" ,
    'type' => MENU_LOCAL_TASK,
    'page callback' => '_cybcom_loadNodeHtml',
    'page arguments' => array(1),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),

  );

 $items['node/%cybcom_menu/cybcom/json'] = array (
   'title' =>"JSON" ,
   'type' => MENU_NORMAL_ITEM,
   'page callback' => '_cybcom_loadNode',
   'page arguments' => array(1),
   'access callback' => 'node_access',
   'access arguments' => array('update', 1),
   'delivery callback' => 'drupal_json_output',
 );

 return $items;
}


/**
 * Menu loader callback.
 */
function cybcom_menu_load($nid) {
  if (!is_numeric($nid)) {
    return FALSE;
  }
  $node = node_load($nid);
  if($node->type == 'item') {
    return $node;
  }
  return FALSE;
}

/**
 *  Post to cybercommns to get XML representation of node
 */
function cybcom_mintxml($nid) {
  watchdog('cybcom', "mintxml called for node ". $nid );

  try {
    # load data to mint
    $nd = entity_load_single('node', $nid);
    $bd = $nd->type;
    $w = entity_metadata_wrapper("node", $nd, array('bundle' => $bd));

    # get config
    $cybcom_xmlurl = variable_get('cybcom_xmlurl', "");
    $cybcom_token = variable_get('cybcom_token', "");

    # structure as array for cybercommons
    $cybcom_data = _cybcom_wrap2array($w);

    #send to cyber commonds
    $response = _send2cybcom($cybcom_xmlurl, $cybcom_token, "speccoll.tmpl", $cybcom_data);

    # save resonse url
    $task= $response->json();


    $w->field_cybcom_task->set($task['task_id'] );
    $w->field_cybcom_task_uri->set( array( 'url'=>$task['result_url']));
    $w->save();

  } catch (EntityMetadataWrapperException $exc) {
    watchdog(
      'cybcom',
      'EntityMetadataWrapper exception in %function() <pre>@trace</pre>',
      array('%function' => __FUNCTION__, '@trace' => $exc->getTraceAsString()),
      WATCHDOG_ERROR
    );
  }


}


function _cybcom_loadNode($node) {

 try {
   $nid = $node->nid;
   # load data to mint
   $nd = entity_load_single('node', $nid);
   $bd = $nd->type;
   $w = entity_metadata_wrapper("node", $nd, array('bundle' => $bd));

   return _cybcom_wrap2array($w);

  } catch (EntityMetadataWrapperException $exc) {
    watchdog(
      'cybcom',
      'EntityMetadataWrapper exception in %function() <pre>@trace</pre>',
      array('%function' => __FUNCTION__, '@trace' => $exc->getTraceAsString()),
      WATCHDOG_ERROR
    );
  }
}

function _cybcom_loadNodeHtml($node) {

  $ccArray = _cybcom_loadNode($node);

  $ccArrayMarkup  = '<pre>';
  $ccArrayMarkup .= htmlspecialchars(json_encode($ccArray, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES));
  # We don't want escaped slashes because it looks weird when we turn things in to html
  $ccArrayMarkup .='</pre>';

  $output = array(
    'content'=> array(
      '#type' => 'markup',
      '#markup' => $ccArrayMarkup,
    )


  );
  return $output;
}

function _cybcom_wrap2array($w) {
  $myContent=array();

  foreach ($w->getPropertyInfo() as $key => $val) {

    # $key will be a field name fromt he content type
    # $val will be the (structured) content of that field,

    if("field_creator_info" == $key) {
      $creators = $w->$key;

      $myCreators = array();
      foreach( $creators as $creator) {
        $myCreator = array();

        # TODO This should probably handle errors better

        $myCreator['field_creator_type'] =@ $creator->field_creator_type->value()->name ?: "";
        $myCreator['field_creator_source'] =@ $creator->field_creator_source->value()->name ?: "";
        $myCreator['field_creator_source_corp'] =@ $creator->field_creator_source->value()->name ?: "";
        $myCreator['field_creator_person_lcnaf'] =@ $creator->field_creator_person_lcnaf->value() ?: "";
        $myCreator['field_creator_local_'] =@ $creator->field_creator_local_->value() ?: "";
        $myCreator['field_creator_role'] =@ $creator->field_creator_role->value()->name ?: "";
        $myCreator['field_corporate_name_lcnaf_'] =@ $creator->field_corporate_name_lcnaf_->value() ?: "";
        $myCreator['field_corporate_name_local_'] =@ $creator->field_corporate_name_local_->value() ?: "";
        $myCreator['field_conference_name'] =@ $creator->field_conference_name->value() ?: "";
        array_push($myCreators, $myCreator);

      }
      $myContent[$key] = $myCreators;
      continue;
    }


    switch( $val['type'] )  {

      # Handle single and multi-value text fields.
      case "integer":
      case "boolean":
      case "text":
      case "list<text>":
        $myValue = $w->$key->value();
        if(! empty(  $myValue )) {
          $myContent[$key]=$myValue;
        }
        break;

      case "taxonomy_term":
        $myValue = $w->$key->value();
        if(! empty(  $myValue )) {
          $myContent[$key]=$myValue->name;
        }
        break;

      case "list<taxonomy_term>":
        $myVec = $w->$key->value();
        $myTerms = array();
        foreach( $myVec as $myValue) {
          array_push($myTerms, $myValue->name);
        }
        if(! empty( $myTerms) ) {
          $myContent[$key]=$myTerms;
        }
        break;

      case "date":
        $myValue = $w->$key->value();
        if(! empty(  $myValue )) {
          $myContent[$key]=date(DATE_RFC2822, $myValue);
        }

      case "list<date>":
        $myVec = $w->$key->value();
        if(! is_array($myVec)) {break;} // Bad style?

        $myDates = array();
        foreach( $myVec as $myTS) {
          array_push($myDates, date(DATE_RFC2822. $myTS));
        }
        if(! empty( $myTerms) ) {
          $myContent[$key]=$myDates;
        }
        break;

      default:
        # Log unhandled fields. Eventually this should be an error
        watchdog("cybcom",
          "Unhandled field %field of type %type in node %nid.",
          array("%field"=>$key, "%nid" => $w->nid->value(), "%type"=> $val['type']  )
        );
    }
  }
return $myContent;
}



function _send2cybcom($cybcom_xmlurl, $cybcom_token, $cybcom_template, $cybcom_data) {

  $cyb_client = new GuzzleHttp\Client([
                  'defaults' => [
                    'headers' => [
                      'Content-Type'=>'application/json',
                      "Authorization"=>"Token ".$cybcom_token,
                    ]]]);

  $cyb_body = [
    "function"=>"xmlgenq.tasks.xmltemplate.metadataTemplateCreation",
    "queue"=>"celery",
    "args" => [
      $cybcom_data,
    ],
    "kwargs"=> [
      "templatename"=>$cybcom_template,
      "outname"=>$cybcom_template.".xml"
    ],
    "tags"=> ["example.xml"],
  ];

  $response = $cyb_client->post(
    $cybcom_xmlurl."/api/queue/run/xmlgenq.tasks.xmltemplate.metadataTemplateCreation/.json",
    ['body' => json_encode($cyb_body),]
  );


  return $response;
}
